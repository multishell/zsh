#autoload

local prev

# A `--' as the first argument says that we should tell comptags to use
# the preceding function nesting level. This is only documented here because
# if everythings goes well, users won't have to worry about it and should
# not mess with it.

if [[ "$1" = -- ]]; then
  prev=-
  shift
fi

if (( $# )); then

  # We have arguments: the tags supported in this context.

  local curcontext="$curcontext" order tag nodef tmp

  if [[ "$1" = -C?* ]]; then
    curcontext="${curcontext%:*}:${1[3,-1]}"
    shift
  elif [[ "$1" = -C ]]; then
    curcontext="${curcontext%:*}:${2}"
    shift 2
  else
    targs=()
  fi

  [[ "$1" = -(|-) ]] && shift

  if zstyle -a ":completion:${curcontext}:" group-order order; then
    local name

    for name in "$order[@]"; do
      compadd -J "$name"
      compadd -V "$name"
      compadd -J "$name" -1
      compadd -V "$name" -1
      compadd -J "$name" -2
      compadd -V "$name" -2
    done
  fi

  # Set and remember offered tags.

  comptags "-i$prev" "$curcontext" "$@"

  # Sort the tags.

  if [[ -n "$_sort_tags" ]]; then
    "$_sort_tags" "$@"
  else
    zstyle -a ":completion:${curcontext}:" tag-order order ||
        order=('(|*-)argument-* (|*-)option-* values' options)

    for tag in $order; do
      case $tag in
      -)     nodef=yes;;
      *\(\)) if ! "${${tag%%[ 	]#\(\)}##[ 	]#}" "$@"; then
               nodef=yes
               break
             fi
             ;;
      \!*)   comptry "${(@)argv:#(${(j:|:)~${=~tag[2,-1]}})}";;
      ?*)    comptry -m "$tag";;
      esac
    done

    [[ -z "$nodef" ]] && comptry "$@"
  fi

  # Return non-zero if at least one set of tags should be used.

  comptags "-T$prev"

  return
fi

# The other mode: switch to the next set of tags.

comptags "-N$prev"
