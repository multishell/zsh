#autoload

_bash_complete() {
  local ret=1
  local -a suf matches
  local COMP_POINT COMP_CWORD
  local -a COMP_WORDS COMPREPLY BASH_VERSINFO
  local COMP_LINE="$words"
  local -A savejobstates savejobtexts
  set -- $=_bash_comps[$service]

  (( COMP_POINT = 1 + ${#${(j. .)words[1,CURRENT-1]}} + $#QIPREFIX + $#IPREFIX + $#PREFIX ))
  (( COMP_CWORD = CURRENT - 1))
  COMP_WORDS=( $words )
  BASH_VERSINFO=( 2 05b 0 1 release )
  
  savejobstates=( ${(kv)jobstates} )
  savejobtexts=( ${(kv)jobtexts} )
  
  [[ ${argv[${argv[(I)nospace]:-0}-1]} = -o ]] && suf=( -S '' )
 
  matches=( ${(f)"$(compgen $@)"} )
  
  if [[ -n $matches ]]; then
    if [[ ${argv[${argv[(I)filenames]:-0}-1]} = -o ]]; then
      compset -P '*/' && matches=( ${matches##*/} )
      compset -S '/*' && matches=( ${matches%%/*} )
      compadd -f "${suf[@]}" -a matches && ret=0
    else
      compadd "${suf[@]}" -a matches && ret=0
    fi
  fi

  if (( ret )); then
    if [[ ${argv[${argv[(I)default]:-0}-1]} = -o ]]; then
      _default "${suf[@]}" && ret=0
    elif [[ ${argv[${argv[(I)dirnames]:-0}-1]} = -o ]]; then
      _directories "${suf[@]}" && ret=0
    fi
  fi

  return ret
}

compgen() {
  local opts prefix suffix job OPTARG OPTIND ret=1 
  local -a name res results jids
  local -A shortopts
  
  emulate -L sh
  setopt kshglob noshglob braceexpand nokshautoload

  shortopts=(
    a alias b builtin c command d directory e export f file
    g group j job k keyword u user v variable
  )

  while getopts "o:A:G:C:F:P:S:W:X:abcdefgjkuv" name; do
    case $name in
      [abcdefgjkuv]) OPTARG="${shortopts[$name]}" ;&
      A)
        case $OPTARG in
	  alias) results=( "${results[@]}" "${(k)aliases[@]}" ) ;;
	  arrayvar) results=( "${results[@]}" "${(k@)parameters[(R)array*]}" ) ;;
	  binding) results=( "${results[@]}" "${(k)widgets[@]}" ) ;;
	  builtin) results=( "${results[@]}" "${(k)builtins[@]}" "${(k)dis_builtins[@]}" ) ;;
	  command)
	    results=(
	      "${results[@]}" "${(k)commands[@]}" "${(k)aliases[@]}"
	      "${(k)builtins[@]}" "${(k)functions[@]}" "${(k)reswords[@]}"
	    )
	  ;;
	  directory)
	    setopt bareglobqual
	    results=( "${results[@]}" ${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N-/) )
	    setopt nobareglobqual
	  ;;
	  disabled) results=( "${results[@]}" "${(k)dis_builtins[@]}" ) ;;
	  enabled) results=( "${results[@]}" "${(k)builtins[@]}" ) ;;
	  export) results=( "${results[@]}" "${(k)parameters[(R)*export*]}" ) ;;
	  file)
	    setopt bareglobqual
	    results=( "${results[@]}" ${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N) )
	    setopt nobareglobqual
	  ;;
	  function) results=( "${results[@]}" "${(k)functions[@]}" ) ;;
	  group)
	    emulate zsh
	    _groups -U -O res
	    emulate sh
	    setopt kshglob noshglob braceexpand
	    results=( "${results[@]}" "${res[@]}" )
	  ;;
	  hostname)
	    emulate zsh
	    _hosts -U -O res
	    emulate sh
	    setopt kshglob noshglob braceexpand
	    results=( "${results[@]}" "${res[@]}" )
	  ;;
	  job) results=( "${results[@]}" "${savejobtexts[@]%% *}" );;
	  keyword) results=( "${results[@]}" "${(k)reswords[@]}" ) ;;
	  running)
	    jids=( "${(@k)savejobstates[(R)running*]}" )
	    for job in "${jids[@]}"; do
	      results=( "${results[@]}" ${savejobtexts[$job]%% *} )
	    done
	  ;;
	  stopped)
	    jids=( "${(@k)savejobstates[(R)suspended*]}" )
	    for job in "${jids[@]}"; do
	      results=( "${results[@]}" ${savejobtexts[$job]%% *} )
	    done
	  ;;
	  setopt|shopt) results=( "${results[@]}" "${(k)options[@]}" ) ;;
	  signal) results=( "${results[@]}" "SIG${^signals[@]}" ) ;;
	  user) results=( "${results[@]}" "${(k)userdirs[@]}" ) ;;
      	  variable) results=( "${results[@]}" "${(k)parameters[@]}" ) ;;
	  helptopic) ;;
	esac
      ;;
      F)
        COMPREPLY=()
	$OPTARG "${words[0]}" "${words[CURRENT-1]}" "${words[CURRENT-2]}"
	results=( "${results[@]}" "${COMPREPLY[@]}" )
      ;;
      G)
        setopt nullglob
        results=( "${results[@]}" ${~OPTARG} )
	unsetopt nullglob
      ;;
      W) eval "results=( "${results[@]}" $OPTARG )" ;;
      C) results=( "${results[@]}" $(eval $OPTARG) ) ;;
      P) prefix="$OPTARG" ;;
      S) suffix="$OPTARG" ;;
      X)
        if [[ ${OPTARG[0]} = '!' ]]; then
	  results=( "${(M)results[@]:#${OPTARG#?}}" )
	else
 	  results=( "${results[@]:#$OPTARG}" )
	fi
      ;;
    esac
  done
  
  # support for the last, `word' option to compgen. Zsh's matching does a
  # better job but if you need to, comment this in and use compadd -U
  #shift $(( OPTIND - 1 ))
  #(( $# )) && results=( "${(M)results[@]:#$1*}" )

  print -l -- "$prefix${^results[@]}$suffix"
}

complete() {
  emulate -L zsh
  local args void cmd print remove
  args=( "$@" )
  zparseopts -D -a void o: A: G: W: C: F: P: S: X: a b c d e f g j k u v \
      p=print r=remove
  if [[ -n $print ]]; then
    for cmd in ${(k)_bash_comps}; do
      print "complete ${_bash_comps[$cmd]} $cmd"
    done
  elif [[ -n $remove ]]; then
    for cmd; do
      unset "_bash_comps[$cmd]"
    done
  else
    for cmd; do
      _bash_comps[$cmd]="${args[1,-1-$#]}"
    done
    compdef _bash_complete "$@"
  fi
}

typeset -gA _bash_comps
unfunction bashcompinit
autoload -U bashcompinit
return 0
