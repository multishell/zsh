#autoload

local subopts opt usecc

subopts=()
while [[ "$1" = -(O*|C) ]]; do
  case "$1" in
  -C) usecc=yes; shift ;;
  -O) subopts=( "${(@P)2}" ); shift 2 ;;
  *)  subopts=( "${(@P)1[3,-1]}" ); shift ;;
  esac
done

if compvalues -i "$@"; then

  local noargs args opts descr action expl sep subc
  local oldcontext="$curcontext"

  if ! compvalues -D descr action; then

    _tags values || return 1

    curcontext="${oldcontext%:*}:values"

    compvalues -V noargs args opts

    if [[ "$PREFIX" = *\=* ]]; then
      local name

      name="${PREFIX%%\=*}"
      if compvalues -L "$name" descr action; then
        IPREFIX="${IPREFIX}${name}="
        PREFIX="${PREFIX#*\=}"
      else
        local prefix suffix

	prefix="${PREFIX#*\=}"
	suffix="$SUFFIX"
	PREFIX="$name"
	SUFFIX=''
	args=( "$args[@]" "$opts[@]" )
	compadd -M 'r:|[_-]=* r:|=*' -D args - "${(@)args[@]%%:*}"

	[[ $#args -ne 1 ]] && return 1

        PREFIX="$prefix"
	SUFFIX="$suffix"
        IPREFIX="${IPREFIX}${args[1]%%:*}="
	compvalues -L "${args[1]%%:*}" descr action subc
	curcontext="${oldcontext%:*}:$subc"
      fi
    else
      compvalues -d descr
      if [[ ${#noargs}+${#args}+${#opts} -ne 1 ]] && compvalues -s sep; then
        sep=( "-qQS" "$sep" )
      else
        sep=()
      fi

      _describe "$descr" \
        noargs "$sep[@]" -M 'r:|[_-]=* r:|=*' -- \
        args -S= -M 'r:|[_-]=* r:|=*' -- \
        opts -qS= -M 'r:|[_-]=* r:|=*'

      curcontext="$oldcontext"

      return
    fi
  else
    compvalues -C subc
    curcontext="${oldcontext%:*}:$subc"
  fi

  if ! _tags arguments; then
    curcontext="$oldcontext"
    return 1
  fi

  _description arguments expl "$descr"

  # We add the separator character as a autoremovable suffix unless
  # we have only one possible value left.

  [[ ${#snames}+${#names}+${#onames} -ne 1 ]] && compvalues -s sep &&
      expl=( "-qS$sep" "$expl[@]" )

  if [[ "$action" = -\>* ]]; then
    compvalues -v val_args
    state="${${action[3,-1]##[ 	]#}%%[ 	]#}"
    if [[ -n "$usecc" ]]; then
      curcontext="${oldcontext%:*}:$subc"
    else
      context="$subc"
    fi
    compstate[restore]=''
    return 1
  else
    typeset -A val_args

    compvalues -v val_args

    if [[ "$action" = \ # ]]; then

      # An empty action means that we should just display a message.

      _message "$descr"
      return 1

    elif [[ "$action" = \(\(*\)\) ]]; then
      local ws

      # ((...)) contains literal strings with descriptions.

      eval ws\=\( "${action[3,-3]}" \)

      _describe "$descr" ws -M 'r:|[_-]=* r:|=*' "$subopts[@]"

    elif [[ "$action" = \(*\) ]]; then

      # Anything inside `(...)' is added directly.

      _all_labels arguments expl "$descr" \
          compadd "$subopts[@]" - ${=action[2,-2]}
    elif [[ "$action" = \{*\} ]]; then

      # A string in braces is evaluated.

      while _next_label arguments expl "$descr"; do
        eval "$action[2,-2]"
      done
    elif [[ "$action" = \ * ]]; then

      # If the action starts with a space, we just call it.

      eval "action=( $action )"
      while _next_label arguments expl "$descr"; do
        "$action[@]"
      done
    else

      # Otherwise we call it with the description-arguments built above.

      eval "action=( $action )"
      while _next_label arguments expl "$descr"; do
        "$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}"
      done
    fi
  fi

  curcontext="$oldcontext"

  [[ nm -ne "$compstate[nmatches]" ]]
else
  curcontext="$oldcontext"

  return 1;
fi
