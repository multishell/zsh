comptestinit () {
  setopt extendedglob
  [[ -d $ZTST_testdir/Modules/zsh ]] && module_path=( $ZTST_testdir/Modules )
  fpath=( $ZTST_srcdir/../(Completion|Functions)/*~*/CVS(/) )

  zmodload -i zsh/zpty

  comptest_zsh=${ZSH:-zsh}
  termcap_ce="$(echotc ce)"

  while getopts z: opt; do
    case $opt in
      z) comptest_zsh="$OPTARG";;
    esac
  done
  (( OPTIND > 1 )) && shift $(( OPTIND - 1 ))

  export PS1="<PROMPT>"
  zpty zsh "$comptest_zsh" -f

  zpty -r zsh log1 "*<PROMPT>*" || { 
    print "first prompt doesn't appered."
    return 1
  }

  comptesteval \
"module_path=( $module_path )" \
"fpath=( $fpath )" \
"ZLS_COLORS='no=<NO>:fi=<FI>:di=<DI>:ln=<LN>:pi=<PI>:so=<SO>:bd=<BD>:cd=<CD>:ex=<EX>:mi=<MI>:tc=<TC>:sp=<SP>:lc=<LC>:ec=<EC>\\n:rc=<RC>'" \
'LISTMAX=10000000
stty columns 80 rows 24
bindkey -e
autoload -U compinit
compinit $dump
zstyle ":completion:*" group-name ""
zstyle ":completion*:messages" format "<MESSAGE>%d</MESSAGE>
"
zstyle ":completion*:descriptions" format "<DESCRIPTION>%d</DESCRIPTION>
"
zstyle ":completion*:options" verbose yes
zstyle ":completion*:values" verbose yes
setopt noalwayslastprompt listrowsfirst completeinword
zmodload zsh/complist
expand-or-complete-with-report () {
  print -lr "<WIDGET><expand-or-complete>"
  zle expand-or-complete
  print -lr - "<LBUFFER>$LBUFFER</LBUFFER>" "<RBUFFER>$RBUFFER</RBUFFER>"
  zle clear-screen
  zle -R
}
list-choices-with-report () {
  print -lr "<WIDGET><list-choices>"
  zle list-choices
  zle clear-screen
  zle -R
}
finish () {
  print "<WIDGET><finish>"
  zle kill-whole-line
  zle clear-screen
  zle -R
}
zle -N expand-or-complete-with-report
zle -N list-choices-with-report
zle -N finish
bindkey "^I" expand-or-complete-with-report
bindkey "^D" list-choices-with-report
bindkey "^Z" finish
'
}

comptesteval () {
  local tmp=/tmp/comptest.$$

  print -lr - "$@" > $tmp
  zpty -w zsh ". $tmp"
  zpty -r zsh log_eval "*<PROMPT>*" || {
    print "prompt doesn't appered."
    return 1
  }
  rm $tmp
}

comptest () {
  input="$*"
  zpty -n -w zsh "$input"$'\C-Z'
  zpty -r zsh log "*<WIDGET><finish>*<PROMPT>*" || {
    print "finish widget doesn't invoked."
    return 1
  }

  logs=(${(s:<WIDGET>:)log})
  shift logs

  for log in "$logs[@]"; do
    if [[ "$log" = (#b)*$'<LBUFFER>'(*)$'</LBUFFER>\r\n<RBUFFER>'(*)$'</RBUFFER>'* ]]; then
      print -lr "line: {$match[1]}{$match[2]}"
    fi
    while (( ${(N)log#*(#b)(<LC><(??)><RC>(*)<EC>|<DESCRIPTION>(*)</DESCRIPTION>|<MESSAGE>(*)</MESSAGE>|<COMPADD>(*)</COMPADD>)} )); do
      log="${log[$mend[1]+1,-1]}"
      if (( 0 <= $mbegin[2] )); then
	if [[ $match[2] != TC && $match[3] != \ # ]]; then
	  print -lr "$match[2]:{${match[3]%$termcap_ce}}"
	fi
      elif (( 0 <= $mbegin[4] )); then
	print -lr "DESCRIPTION:{$match[4]}"
      elif (( 0 <= $mbegin[5] )); then
	print -lr "MESSAGE:{$match[5]}"
      elif (( 0 <= $mbegin[6] )); then
        print -lr "COMPADD:{${${match[6]}//[$'\r\n']/}}"
      fi
    done
  done
}
